% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nearest_point.R
\name{nearest_point}
\alias{nearest_point}
\alias{nearest_profile}
\title{Calculate nearest point in convex hull}
\usage{
nearest_point(idx, citations, communities, self = TRUE)

nearest_profile(idx = NULL, citations, communities, self = TRUE)
}
\arguments{
\item{idx}{A journal name or index. Vectorised for \code{nearest_profile()}.}

\item{communities}{A membership vector or \link[igraph:communities]{igraph::communities} object.}

\item{self}{logical. Include self-citations? If \code{FALSE}, they will not be counted.}
}
\value{
\code{nearest_point} returns the list generated by \code{\link[quadprog:solve.QP]{quadprog::solve.QP()}}.

\code{nearest_profile()} returns a stochastic vector whose length is equal
to the number of rows/vertices in \code{citations}. It is also vectorised, so if
\code{idx} has length > 1, a matrix will be returned instead.
}
\description{
Given a citation matrix and a community structure, \code{nearest_point} calculates the point
in the convex hull of community profiles that is nearest to a given journal profile.
}
\details{
This function uses quadratic programming to calculate the closest point by Euclidean distance.
The \code{citations} matrix should be arranged so that citations are directed from columns to rows.
If \code{idx} is a name, it should correspond to a row name from \code{citations}.

The function \code{nearest_profile} is a shorthand way to calculate the \emph{profile} corresponding
to the nearest point.
}
\examples{
counts <- citations[1:6, 1:6]
comms <- setNames(c(1, 2, 3, 2, 2, 4), colnames(counts))
nearest_point('AoS', counts, comms) # Inside hull (value == 0), because AoS is itself a community.
nearest_point('ANZS', counts, comms) # Outside hull, near to its own community.

# To which cluster should 'Biometrika' belong?
distances <- as.dist(1 - cor(citations + t(citations)))
clusters <- cutree(hclust(distances), h = 0.8)
result <- nearest_point('Bka', citations, clusters)
# Verify Euclidean distance is calculated correctly:
point <- community_profile(citations, clusters) \%*\% result$solution
result$value \%=\% sum((citations[, 'Bka'] / sum(citations[, 'Bka']) - point)^2)

}
\seealso{
\code{\link[quadprog:solve.QP]{quadprog::solve.QP()}}, \code{\link[=community_profile]{community_profile()}}
}
